[A](https://vjudge.net/contest/644146#problem/A)
题意: 有$n$个小吃摊, 每个小吃摊能够提供$a_i$的乐趣值, Bob只能吃$k$个, 求能获得的最大乐趣值.

排序一下取最大的$k$个就行.

``` cpp
using i64 = int64_t;
void solve()
{
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    sort(a.begin(), a.end(), greater<>());
    i64 ans = 0;
    for (int i = 0; i < k; i++)
    {
        ans += a[i];
    }
    cout << ans << '\n';
}
```

[B](https://vjudge.net/contest/644146#problem/B)
题意: 给定一个生命值$h$, 与两个操作的操作次数$n, m$. 第一种操作将$h$变为$\lfloor \frac{h}{2} \rfloor + 10$, 第二种操作将$h$变为$h - 10$. 问能否使$h \leq 0$.

第一种操作将$h$减半, 因此在$h$数值较大时使用更优. 但是至多将$h$削减到20以下, 因此需要在$h \leq 20$时使用两次第二种操作才可以将$h$削减到$0$以下.

``` cpp
void solve()
{
    int cnt[2] = {};
    int n;
    cin >> n >> cnt[0] >> cnt[1];
    while (cnt[0] + cnt[1] > 0 && n > 0)
    {
        int dec1 = n - (n / 2 + 10);
        int dec2 = 10;
        if (n > 20 &&  cnt[0] > 0)
        {
            cnt[0]--;
            n -= dec1;
        }
        else if(cnt[1] > 0)
        {
            cnt[1]--;
            n -= dec2;
        }
        else
        {
            break;
        }
    }

    cout << (n <= 0 ? "YES" : "NO") << '\n';
}
```


[C](https://vjudge.net/contest/644146#problem/C)
贪心地选择结束时间更早的比赛. 因为本题要求的是最多能参加比赛的数目, 而选择结束时间更早的比赛能够为后面的比赛预留更多的时间. 

``` cpp
using pii = pair<int, int>;
void solve()
{
    int n;
    cin >> n;
    vector<pii> a(n);
    for (int i = 0; i < n; i++)
    {
        int l, r;
        cin >> l >> r;
        a[i] = {l, r};
    }
    sort(a.begin(), a.end(), [](pii const& l, pii const& r)
        {
            return l.second < r.second;
        });
    int ans = 0;
    int last = -1;
    for (auto [l, r] : a)
    {
        if (l >= last)
        {
            ans++;
            last = r;
        }
    }
    cout << ans << '\n';
}
```

[D](https://vjudge.net/contest/644146#problem/D)
题意: 给定$n$天的产品数量$k_i$与客户数量$l_i$, 每位客户会购买一个产品, 有$f$次机会将当日的产品数量翻倍. 问最多能销售出多少件产品.

每个天数选择翻倍后获得的价值不同, 显然将翻倍的机会用到增加销售额最多的天数能够获得最大的收益.

``` cpp
using i64 = int64_t;
using pii = pair<int, int>;
void solve()
{
    int n, k;
    cin >> n >> k;
    vector<pii> a(n);
    for (int i = 0; i < n; i++)
    {
        int x, y;
        cin >> x >> y;
        a[i] = {x, y};
    }
    sort(a.begin(), a.end(), [](pii const& l, pii const& r)
        {
            int add1 = min(l.first * 2, l.second) - min(l.first, l.second);
            int add2 = min(r.first * 2, r.second) - min(r.first, r.second);
            return add1 > add2;
        });
    i64 ans = 0;
    for (int i = 0; i < k; i++)
    {
        auto [l, r] = a[i];
        l *= 2;
        ans += min(l, r);
    }
    for (int i = k; i < n; i++)
    {
        auto [l, r] = a[i];
        ans += min(l, r);
    }
    cout << ans << '\n';
}
```

[E](https://vjudge.net/contest/644146#problem/E)
题意: 给定$n, r$分别表示加热器的数量和加热器的覆盖半径, 数组$a$, 当$a_i$为$1$时表示第$i$个位置有一个加热器, 其覆盖区域为$[a_i - r + 1, a_i + r - 1]$. 求将所有位置加热所需的使用的最少的加热器数量, 如果无法将所有位置加热输出$-1$.

从左到右考虑, 令$last$作为受到加热的右界, 贪心地选择最靠右的且能覆盖$last$右侧相邻区域的加热器. 选择尽量靠右的的加热器能够将$last$向右伸展地更多, 提供更多的覆盖区间.

``` cpp
void solve()
{
    int n, r;
    cin >> n >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    int ans = 0;
    int last = -1;
    while (last < n - 1)
    {
        int pos = -1;
        for (int i = n - 1; i > max(last - r + 1, -1); i--)
        {
            if (a[i] == 1 && i - r <= last)
            {
                pos = i;
                break;
            }
        }
        if (pos == -1)
        {
            cout << -1 << '\n';
            return;
        }
        ans++;
        last = pos + r - 1;
    }
    cout << ans << '\n';
}
```


[F](https://vjudge.net/contest/644146#problem/F)
将速度小的放在公路的前方, 因为速度越大能够接受更多的汽车在它前方.
第一排的最小速度为$L + D * 0$, 第二排最小速度为$L + D * 1$...对于每一排, 可以使用二分法找到第一个大于等于这一排最小速度的汽车, 随后按顺序将汽车放在这一排.

``` cpp
void solve()
{
    int n, m, D, L;
    cin >> n >> m >> D >> L;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    sort(a.begin(), a.end());

    int ans = 0;
    int now;
    int pre = -1;
    for (int i = 0; L + D * i <= a.back(); i++)
    {
        now = lower_bound(a.begin(), a.end(), L + D * i) - a.begin();
        now = max(now, pre);
        for (int j = 0; j < m; j++)
        {
            if (now < n)
            {
                ans++;
                now++;
            }
            else
            {
                break;
            }
        }
        pre = now;
    }
    cout << ans << '\n';
}
```

[G](https://vjudge.net/contest/644146#problem/G)
题意: 给定一串字符串仅包含"?", "(", ")", 令所有 "?" 变为 "(" 或 ")", 使得整串为合法的括号序列且除此之外的任何前缀均为不合法括号序列.

将 "(" 的权重定为 1, ")" 的权重定为 -1, 问题转化成整串的前缀和为 0 且除此之外的任何前缀和均大于0.
我们想让前缀和尽可能少地去接触0, 因此对于左侧尽可能填 "(" 能让前缀和尽可能大, 从而达到我们想要的效果. 

``` cpp
void solve()
{
    int n;
    cin >> n;
    string s;
    cin >> s;
    if (n % 2 == 1)
    {
        cout << ":(" << '\n';
        return;
    }

    int cnt = std::count(s.begin(), s.end(), '(');
    for (int i = 0; i < n; i++)
    {
        if (s[i] == '?')
        {
            if (cnt < n / 2)
                s[i] = '(', cnt++;
            else
                s[i] = ')';
        }
    }

    // check
    stack<char> stk;
    for (int i = 0; i < n; i++)
    {
        char ch = s[i];
        if (ch == '(')
            stk.emplace(ch);
        else
        {
            if (stk.empty())
            {
                cout << ":(" << '\n';
                return;
            }
            stk.pop();

            if (stk.empty() && i != n - 1)
            {
                cout << ":(" << '\n';
                return;
            }
        }
    }
    if (!stk.empty())
    {
        cout << ":(" << '\n';
        return;
    }

    cout << s << '\n';
}
```

[H](https://vjudge.net/contest/644146#problem/H)

选取相邻的两个大臣 $i$ 和 $j$ ( 令 $i$ < $j$ ), 分别用 $a_i, b_i, a_j, b_j$ 表示这两位大臣左手上和右手上的数字，设这两位大臣前面的所有大臣左手上的数乘积为 $k$.

此时, 若调整这两名大臣的顺序, 对前面和后面的大臣都不会造成影响, 因此我们只要使得这两位大臣中获得较多奖赏的那位获得的奖赏尽量少即可. 

当 $i$ 在前 $j$ 在后时, 这个值为 $max(\frac k{b_i},\frac {k a_i}{b_j})$. 

当 $j$ 在前 $i$ 在后时, 这个值为 $max(\frac k{b_j},\frac {k a_j}{b_i})$. 

因此, 若 $max(\frac k{b_i}, \frac {k a_i}{b_j})>max(\frac k{b_j}, \frac {k a_j}{b_i})$, 就需要交换 $i$ 和 $j$.

实际上, 由于 $\frac {k a_i}{b_j}\ge\frac k{b_j}, \frac {k a_j}{b_i}\ge\frac k{b_i}$, 只需比较 $\frac {k a_i}{b_j}$ 和 $\frac {k a_j}{b_i}$, 也就只需比较 $\frac {a_i}{b_j}$ 和 $\frac {a_j}{b_i}$, 即: 若 $a_i b_i>a_j b_j$, 就要交换 $i$ 和 $j$. 


[I](https://vjudge.net/contest/644146#problem/I)
需要让 $A, B$ 的等待时间之和最短.
显然 $A$ 需要一刻不停地开工.
如何让 $B$ 等待时间最短? 很明显需要让 $B$ 尽可能早开工, 于是需要让 $A$ 加工时间短的先开工.
$A$ 不需要等待 $B$, 不过我们可以将 $A$ 完工到最终完工的时间作为其等待的时间. 那么将 $B$ 中加工时间最短的放在最后加工, 这样使得 $A$ 机器用最短时间等待 $B$ 机器完工.

于是得出这样的贪心策略:
令 $M_i$ 为 $min(A_i, B_i)$, 将 $M$ 按递增排序. 如果 $M_i = A_i$ 则将它排在从头开始的作业后面, 否则将其排在从尾开始的作业前面.

``` cpp
void solve()
{
    int n;
    cin >> n;
    vector<array<int, 4>> arr(n);
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i][0];
    }
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i][1];
        arr[i][2] = min(arr[i][0], arr[i][1]);
        arr[i][3] = i;
    }
    auto cp = arr;
    sort(arr.begin(), arr.end(), [](auto const& l, auto const& r)
        {
            return l[2] < r[2];
        });

    vector<int> ans(n);
    int l = 0, r = n - 1;
    for (auto [a, b, m, index] : arr)
    {
        if (m == a)
            ans[l++] = index;
        else
            ans[r--] = index;
    }

    int tim[2] = {};
    for (auto x : ans)
    {
        tim[0] += cp[x][0];
        tim[1] = max(tim[0], tim[1]);
        tim[1] += cp[x][1];
    }
    cout << tim[1] << '\n';

    for (auto x : ans)
        cout << x + 1 << ' ';
    cout << '\n';
}
```


[J](https://vjudge.net/contest/644146#problem/J)
题意: 给定一个数 $N$, 从 $[1, N]$ 中挑选一个数使它反转后的值最大.

策略: 尽量不缩位, 能减的位尽量让其减成 $9$, 否则保持不变.
+ 如果 $N$ 只有一位数如 $2$. 无法减, 直接输出.
+ 如果 $N$ 第一位为 $1$, 其它全为 $0$, 如 $1000$. 此时必须将其减一变成全 $9$ 的数, 不然翻转后是 $1$.
+ 如果 $N$ 第一位为 $1$, 最后一位不为 $0$, 其余全为 $0$, 如 $1003$. 无法减, 直接输出.
+ 如果 $N$ 第一位为 $1$, 接一段连续的 $0$, 最后几位都为 $9$, 如 $100299$. 无法减, 直接输出.
+ 如果 $N$ 第一位为 $1$, 接一段连续的 $0$, 最后几位不全为 $9$, 如 $100139$. 则将第一个不为 $0$ 的数字减一输出, 剩下几位均输出 $9$.
+ 如果 $N$ 第一位不为 $1$, 其它全为 $9$, 如 $29999$. 直接输出.
+ 如果 $N$ 第一位不为 $1$, 其它不全为 $9$, 如 $29129$. 则将首位减一输出, 其余均输出 $9$.


[K](https://vjudge.net/contest/644146#problem/K)
由于异或不会进位, 因此考虑按位拆分去做, 问题变成在$0/1$序列上将一些未知的位置填上$0/1$, 使得所有前缀异或和最小.
每个区间的后面填这个区间的异或和就可以抵消这个区间的贡献, 因此考虑一个连续区间前面的那一个未知数, 可以计算区间中$0/1$的数量, 选择其中数量较少的加上该位的权值 $2^i$. 如果区间前面无未知数即该区间从1开始, 则不能改变, 只能加上所有的 $1$ 的数量.

``` cpp
using i64 = int64_t;
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<array<int, 2>> a(m);
    for (int i = 0; i < m; i++)
    {
        cin >> a[i][0] >> a[i][1];
    }
    sort(a.begin(), a.end());

    i64 ans = 0;
    for (int i = 0; i < 30; i++)
    {
        for (int j = 0, k = 0; j < m; j = k)
        {
            int x = 0;
            int cnt = 0; // 1的数量
            while (k < m && (j == k || a[k][0] - 1 == a[k - 1][0])) // 连续段[j,k)
            { 
                x ^= (a[k][1] >> i) & 1;
                if (x)
                    cnt++;
                k++;
            }
            if (a[j][0] == 1) // 从1开始的连续段没的选
                ans += (1ll << i) * cnt;
            else
                ans += (1ll << i) * min(cnt, a[k - 1][0] - a[j][0] + 2 - cnt); // 连续段前一位填0或1
        }
    }
    cout << ans << '\n';
}
```


[L](https://vjudge.net/contest/644146#problem/L)
题意: 给定一个长为 $N$ 的数组 $A$, 将其分成两份 $B, C$, 使得 $GCD(B) + GCD(C)$ 最大.

结论: 当其中一个数组大小为 $1$ 时最大
证明: 
首先有一个易证的引理, 当 $x \ne y$ 时, $gcd(x, y) \leq \frac{max(x, y)}{2}$.
设最大值为 $x$, 若 $size(B) > 1 \text{ and } size(C) > 1$, 则 $gcd(B) \leq \frac{x}{2}$, $gcd(C) \leq \frac{x}{2}$, $gcd(B) + gcd(C) \leq x$.

``` cpp
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    a.erase(unique(a.begin(), a.end()), a.end()); // 去重

    if (a.size() == 1)
    {
        cout << 2 * a.back() << '\n';
        return;
    }
    if (a.size() == 2)
    {
        cout << a[0] + a[1] << '\n';
        return;
    }

    vector<int> g1(a.size()), g2(a.size());
    g1.front() = a.front();
    for (int i = 1; i < a.size(); i++)
    {
        g1[i] = std::gcd(g1[i - 1], a[i]); // cpp17
    }

    g2.back() = a.back();
    for (int i = a.size() - 2; i >= 0; i--)
    {
        g2[i] = std::gcd(g2[i + 1], a[i]);
    }

    int ans = max(g1.front() + g2[1], g1[a.size() - 2] + g2.back());
    for (int i = 1; i < a.size() - 1; i++)
    {
        ans = max(ans, a[i] + std::gcd(g1[i - 1], g2[i + 1]));
    }
    cout << ans << '\n';
}
```
