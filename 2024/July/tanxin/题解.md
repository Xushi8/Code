
[A](https://vjudge.net/contest/644146#problem/A)
题意: 有$n$个小吃摊, 每个小吃摊能够提供$a_i$的乐趣值, Bob只能吃$k$个, 求能获得的最大乐趣值.

排序一下取最大的$k$个就行.

``` cpp
using i64 = int64_t;
void solve()
{
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    sort(a.begin(), a.end(), greater<>());
    i64 ans = 0;
    for (int i = 0; i < k; i++)
    {
        ans += a[i];
    }
    cout << ans << '\n';
}
```

[B](https://vjudge.net/contest/644146#problem/B)
题意: 给定一个生命值$h$, 与两个操作的操作次数$n, m$. 第一种操作将$h$变为$\lfloor h / 2 \rfloor + 10$, 第二种操作将$h$变为$h - 10$. 问能否使$h \leq 0$.

第一种操作将$h$减半, 因此在$h$数值较大时使用更优. 但是至多将$h$削减到20以下, 因此需要在$h \leq 20$时使用两次第二种操作才可以将$h$削减到$0$以下.

``` cpp
void solve()
{
    int cnt[2] = {};
    int n;
    cin >> n >> cnt[0] >> cnt[1];
    while (cnt[0] + cnt[1] > 0 && n > 0)
    {
        int dec1 = n - (n / 2 + 10);
        int dec2 = 10;
        if (n > 20 &&  cnt[0] > 0)
        {
            cnt[0]--;
            n -= dec1;
        }
        else if(cnt[1] > 0)
        {
            cnt[1]--;
            n -= dec2;
        }
        else
        {
            break;
        }
    }

    cout << (n <= 0 ? "YES" : "NO") << '\n';
}
```


[C](https://vjudge.net/contest/644146#problem/C)
题意: 中文就不解释题意了.

贪心地选择结束时间更早的比赛. 因为本题要求的是最多能参加比赛的数目, 而选择结束时间更早的比赛能够为后面的比赛预留更多的时间. 

``` cpp
using pii = pair<int, int>;
void solve()
{
    int n;
    cin >> n;
    vector<pii> a(n);
    for (int i = 0; i < n; i++)
    {
        int l, r;
        cin >> l >> r;
        a[i] = {l, r};
    }
    sort(a.begin(), a.end(), [](pii const& l, pii const& r)
        {
            return l.second < r.second;
        });
    int ans = 0;
    int last = -1;
    for (auto [l, r] : a)
    {
        if (l >= last)
        {
            ans++;
            last = r;
        }
    }
    cout << ans << '\n';
}
```

[D](https://vjudge.net/contest/644146#problem/D)
题意: 给定$n$天的产品数量$k_i$与客户数量$l_i$, 每位客户会购买一个产品, 有$f$次机会将当日的产品数量翻倍. 问最多能销售出多少件产品.

每个天数选择翻倍后获得的价值不同, 而显然将翻倍的机会用到增加销售额最多的天数能够获得最大的收益.

``` cpp
using i64 = int64_t;
using pii = pair<int, int>;
void solve()
{
    int n, k;
    cin >> n >> k;
    vector<pii> a(n);
    for (int i = 0; i < n; i++)
    {
        int x, y;
        cin >> x >> y;
        a[i] = {x, y};
    }
    sort(a.begin(), a.end(), [](pii const& l, pii const& r)
        {
            int add1 = min(l.first * 2, l.second) - min(l.first, l.second);
            int add2 = min(r.first * 2, r.second) - min(r.first, r.second);
            return add1 > add2;
        });
    i64 ans = 0;
    for (int i = 0; i < k; i++)
    {
        auto [l, r] = a[i];
        l *= 2;
        ans += min(l, r);
    }
    for (int i = k; i < n; i++)
    {
        auto [l, r] = a[i];
        ans += min(l, r);
    }
    cout << ans << '\n';
}
```

[E](https://vjudge.net/contest/644146#problem/E)
题意: 给定$n, r$分别表示加热器的数量和加热器的覆盖半径, 数组$a$, 当$a_i$为$1$时表示第$i$个位置有一个加热器, 其覆盖区域为$[a_i - r + 1, a_i + r - 1]$. 求将所有位置加热所需的使用的最少的加热器数量, 如果无法将所有位置加热输出$-1$.

从左到右考虑, 令$last$作为受到加热的右界, 贪心地选择最靠右的且能覆盖$last$右侧相邻区域的加热器. 选择尽量靠右的的加热器能够将$last$向右伸展地更多, 提供更多的覆盖区间.

``` cpp
void solve()
{
    int n, r;
    cin >> n >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];

    int ans = 0;
    int last = -1;
    while (last < n - 1)
    {
        int pos = -1;
        for (int i = n - 1; i > max(last - r + 1, -1); i--)
        {
            if (a[i] == 1 && i - r <= last)
            {
                pos = i;
                break;
            }
        }
        if (pos == -1)
        {
            cout << -1 << '\n';
            return;
        }
        ans++;
        last = pos + r - 1;
    }
    cout << ans << '\n';
}
```


[F](https://vjudge.net/contest/644146#problem/F)
题意: 中文就不解释题意了.

将速度小的放在公路的前方, 因为速度越大能够接受更多的汽车在它前方.
第一排的最小速度为$L + D * 0$, 第二排最小速度为$L + D * 1$...对于每一排, 可以使用二分法找到第一个大于这一排最小速度的汽车, 随后按顺序将汽车放在这一排.

``` cpp
void solve()
{
    int n, m, D, L;
    cin >> n >> m >> D >> L;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    sort(a.begin(), a.end());

    int ans = 0;
    int now;
    int pre = -1;
    for (int i = 0; L + D * i <= a.back(); i++)
    {
        now = lower_bound(a.begin(), a.end(), L + D * i) - a.begin();
        now = max(now, pre);
        for (int j = 0; j < m; j++)
        {
            if (now < n)
            {
                ans++;
                now++;
            }
            else
            {
                break;
            }
        }
        pre = now;
    }
    cout << ans << '\n';
}
```

[G](https://vjudge.net/contest/644146#problem/G)
题意: 给定一串字符串仅包含"?", "(", ")", 令所有 "?" 变为 "(" 或 ")", 使得整串为合法的括号序列且除此之外的任何前缀均为不合法括号序列.

将 "(" 的权重定为 1, ")" 的权重定为 -1, 问题转化成整串的前缀和为 0 且除此之外的任何前缀和均大于0.
我们想让前缀和尽可能少地去接触0, 因此对于左侧尽可能填 "(" 能让前缀和尽可能大, 从而达到我们想要的效果. 

``` cpp
void solve()
{
    int n;
    cin >> n;
    string s;
    cin >> s;
    if (n % 2 == 1)
    {
        cout << ":(" << '\n';
        return;
    }

    int cnt = std::count(s.begin(), s.end(), '(');
    for (int i = 0; i < n; i++)
    {
        if (s[i] == '?')
        {
            if (cnt < n / 2)
                s[i] = '(', cnt++;
            else
                s[i] = ')';
        }
    }

    // check
    stack<char> stk;
    for (int i = 0; i < n; i++)
    {
        char ch = s[i];
        if (ch == '(')
            stk.emplace(ch);
        else
        {
            if (stk.empty())
            {
                cout << ":(" << '\n';
                return;
            }
            stk.pop();

            if (stk.empty() && i != n - 1)
            {
                cout << ":(" << '\n';
                return;
            }
        }
    }

    if (!stk.empty())
    {
        cout << ":(" << '\n';
        return;
    }

    cout << s << '\n';
}
```

[H](https://vjudge.net/contest/644146#problem/H)

选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），分别用 $a_i,b_i,a_j,b_j$ 表示这两位大臣左手上和右手上的数字，设这两位大臣前面的所有大臣左手上的数乘积为 $k$ 。

此时，若调整这两名大臣的顺序，对前面和后面的大臣都不会造成影响，因此我们只要使得这两位大臣中获得较多奖赏的那位获得的奖赏尽量少即可。

当 $i$ 在前 $j$ 在后时，这个值为 $\max(\frac k{b_i},\frac {k a_i}{b_j})$ 。

当 $j$ 在前 $i$ 在后时，这个值为 $\max(\frac k{b_j},\frac {k a_j}{b_i})$ 。

因此，若 $\max(\frac k{b_i},\frac {k a_i}{b_j})>\max(\frac k{b_j},\frac {k a_j}{b_i})$ ，就需要交换 $i$ 和 $j$ 。

实际上，由于 $\frac {k a_i}{b_j}\ge\frac k{b_j},\frac {k a_j}{b_i}\ge\frac k{b_i}$ ，只需比较 $\frac {k a_i}{b_j}$ 和 $\frac {k a_j}{b_i}$ ，也就只需比较 $\frac {a_i}{b_j}$ 和 $\frac {a_j}{b_i}$ ，即：若 $a_i b_i>a_j b_j$，就要交换 $i$ 和 $j$ 。




[L](https://vjudge.net/contest/644146#problem/L)
题意: 给定一个长为 $N$ 的数组 $A$, 将其分成两份 $B, C$, 使得 $GCD(B) + GCD(C)$ 最大.

结论: 当 $B$ 数组大小为 $1$ 时最大
证明: 
首先有一个易证的引理, 当 $x \ne y$ 时, $gcd(x, y) \leq \frac{max(x, y)}{2}$.
设最大值为 $x$, 若 $size(B) > 1 \text{ and } size(C) > 1$, 则 $gcd(B) \leq \frac{x}{2}$, $gcd(C) \leq \frac{x}{2}$, $gcd(B) + gcd(C) \leq x$.

``` cpp
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    a.erase(unique(a.begin(), a.end()), a.end()); // 去重

    if (a.size() == 1)
    {
        cout << 2 * a.back() << '\n';
        return;
    }
    if (a.size() == 2)
    {
        cout << a[0] + a[1] << '\n';
        return;
    }

    vector<int> g1(a.size()), g2(a.size());
    g1.front() = a.front();
    for (int i = 1; i < a.size(); i++)
    {
        g1[i] = std::gcd(g1[i - 1], a[i]); // cpp17
    }

    g2.back() = a.back();
    for (int i = a.size() - 2; i >= 0; i--)
    {
        g2[i] = std::gcd(g2[i + 1], a[i]);
    }

    int ans = max(g1.front() + g2[1], g1[a.size() - 2] + g2.back());
    for (int i = 1; i < a.size() - 1; i++)
    {
        ans = max(ans, a[i] + std::gcd(g1[i - 1], g2[i + 1]));
    }
    cout << ans << '\n';
}
```
